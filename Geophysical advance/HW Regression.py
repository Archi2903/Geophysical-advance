import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import chi2
from mpl_toolkits.mplot3d import Axes3D
# Задача: оценка параметров модели с помощью метода наименьших квадратов (МНК) и анализ неопределенности параметров модели.
# этапы оценки параметров модели с помощью метода наименьших квадратов (МНК) и анализ неопределенности параметров модели.
# 1. Определение модели и параметров
# 2. Сбор данных и определение матрицы наблюдений                                                   
"Стандартные ошибки параметров"
# Covariace matrix Cov(θ) = σ^2 * ((G^T)*G)^-1
# нужна для оценки неопределённости параметров модели
Cov = np.array([
    [88.53, -33.60, -5.33],
    [-33.60, 15.44, 2.67],
    [-5.33, 2.67, 0.48]
])

# mtrue = [10m, 100m/s, 9.8m/s^2] # истинные значения параметров модели
# mL2 = [16.4m, 97.0m/s, 9.4m/s^2] # оценённые параметры модели с учетом шума σ=8м
# σ=8м - noise

# Оценённые параметры

#95% доверительные интервалы это интервалы, в которых истинные значения параметров модели с вероятностью 95% находятся в пределах этих интервалов.
# Для 3 параметров модели (m1, m2, m3) и 10 наблюдений (n=10) степень свободы = n - k = 10 - 3 = 7
# m+-1.968*σ*sqrt(Cov(θ)) оценка параметров модели с учетом шума σ=8м
# mL2 = (((G^T)*G)^-1)(G^T)*d # mL2 = np.linalg.inv(G.T @ G) @ (G.T @ d) np.linalg.inv(G.T @ G) - обратная матрица
mL2 = np.array([16.42, 96.97, 9.41]) # оценённые параметры модели с учетом шума σ=8м
# m1=16.4m-+ 18.4m ->[-2.0, 34.8]
# m2=97.0m/s-+ 7.7m/s ->[89.3, 104.7]
# m3=9.4m/s^2-+ 1.4m/s^2 ->[8.0, 10.8]
# ml2 ист знач попадают в интервалы, а занчит оценка согласуется несмотря на шум

# наблюдается смещение 
# Ковариационная матрица отражает неопределённость оценок из-за шума в данных.
# Результат близок к истинным значениям, но с отклонениями из-за ошибок измерений.
# Result mtrue and mL2 estimate a little bit diffrent because σ=8м - noise

# Критическое значение χ² для 3 степеней свободы и 95% доверия 
# χ² это распределение, которое используется для проверки гипотезы о соответствии модели данным. v=7
chi2_crit = chi2.ppf(0.95, 3)  # ≈7.815 v=7
# chi2_crit равно 7.815, что соответствует 95% доверительному интервалу для 3 степеней свободы.
# при значениях не превышающих 7.815, модель считается адекватной данным.
# Если χ² больше 7.815, то модель не соответствует данным.
"""
Проверка Критическое значение χ²
# Исходные данные
t = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y_observed = np.array([109.4, 187.5, 267.5, 331.9, 386.1, 428.4, 452.2, 498.1, 512.3, 513.0])
sigma = 8

# Параметры модели
m1, m2, m3 = 16.42, 96.97, 9.41

# Прогнозы модели
y_predicted = m1 + m2*t - 0.5*m3*t**2

# 1. Вычисление статистики χ²
chi_squared = np.sum(((y_observed - y_predicted)/sigma)**2)
print(f"χ² статистика: {chi_squared:.2f}")

# 2. Расчет p-значения (исправленная строка)
degrees_of_freedom = len(t) - 3
p_value = 1 - chi2.cdf(chi_squared, degrees_of_freedom)  # Используем chi2 из scipy.stats
print(f"p-значение: {p_value:.2f}")

# 3. Визуализация
import matplotlib.pyplot as plt
x = np.linspace(0, 20, 500)
plt.plot(x, chi2.pdf(x, degrees_of_freedom), label=f'χ² (df={degrees_of_freedom})')
plt.axvline(chi_squared, color='red', linestyle='--', label=f'χ² = {chi_squared:.2f}')
plt.fill_between(x[x>=chi_squared], chi2.pdf(x[x>=chi_squared], degrees_of_freedom), 
                 color='red', alpha=0.2, label=f'p = {p_value:.2f}')
plt.legend()
plt.show()
"""


# Вычисление обратной матрицы ковариации это важный шаг в анализе неопределённости параметров модели.
# Она позволяет оценить, насколько сильно изменяются параметры модели при изменении входных данных.
Cinv = np.linalg.inv(Cov) # np.linalg.inv(Cov) - обратная матрица ковариации

# Собственные значения и векторы Cinv это важные характеристики матрицы, которые позволяют понять, как параметры модели связаны друг с другом.
# Собственные значения показывают, насколько сильно изменяются параметры модели при изменении входных данных.
eigenvals, eigenvecs = np.linalg.eigh(Cinv) # np.linalg.eigh(Cinv) - собственные значения и векторы матрицы Cinv
# Собственные значения и векторы это важные характеристики матрицы, которые позволяют понять, как параметры модели связаны друг с другом.
# Сортировка в порядке убывания собственных значений
eigenvals = eigenvals[::-1] # Сортировка в порядке убывания собственных значений
eigenvecs = eigenvecs[:, ::-1] # Сортировка в порядке убывания собственных векторов

# Длины полуосей эллипсоида доверия
# Собственные значения показывают, насколько сильно изменяются параметры модели при изменении входных данных.
semi_axes = np.sqrt(chi2_crit / eigenvals) # np.sqrt(chi2_crit / eigenvals) - длины полуосей эллипсоида доверия

# Параметризация единичной сферы для построения эллипсоида
# Параметризация единичной сферы это важный шаг в построении эллипсоида доверия.
theta = np.linspace(0, 2*np.pi, 100) # здесь мы создаем 100 точек от 0 до 2π, чтобы получить полный круг
circle = np.array([np.cos(theta), np.sin(theta)]) # np.array([np.cos(theta), np.sin(theta)]) - единичная окружность в 2D
# Здесь мы создаем 100 точек от 0 до 2π, чтобы получить полный круг

# Создаем 3 отдельных графикa
fig, axs = plt.subplots(1, 3, figsize=(18, 5))

# Для каждой проекции
for i, (pair, ax) in enumerate(zip([(0,1), (0,2), (1,2)], axs)):
    # Выбираем индексы параметров для проекции
    idx1, idx2 = pair
    
    # Выделяем подматрицу ковариации для выбранных параметров 
    # это нужно для построения эллипсоида доверия
    # получаем подматрицу ковариации для выбранных параметров
    # Cov_sub = Cov[[idx1, idx1], [idx2, idx2]] - это не верно
    
    Cov_sub = Cov[[[idx1, idx1], [idx2, idx2]], [[idx1, idx2], [idx1, idx2]]]
    
    # Создаем эллипс для проекции
    L = np.linalg.cholesky(Cov_sub)  # Разложение Холецкого
    ellipse = (L @ (circle * np.sqrt(chi2_crit)) + mL2[[idx1, idx2]].reshape(2,1))
    
    # Рисуем эллипс
    ax.plot(ellipse[0], ellipse[1], color='blue', alpha=0.5)
    ax.scatter(mL2[idx1], mL2[idx2], color='red', s=50)
    
    # Подписи осей
    labels = ['m1 (м)', 'm2 (м/с)', 'm3 (м/с²)']
    ax.set_xlabel(labels[idx1])
    ax.set_ylabel(labels[idx2])
    
    # Названия графиков
    titles = [' p(m1, m2) -0.91', ' (m1, m3) -0.81', ' (m2, m3) 0.97']
    ax.set_title(titles[i])
    
    # Сетка и оформление
    ax.grid(True, linestyle='--', alpha=0.7)
    ax.axhline(0, color='black', linewidth=0.5)
    ax.axvline(0, color='black', linewidth=0.5)
plt.tight_layout()
plt.show()